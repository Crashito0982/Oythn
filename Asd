import pandas as pd
from calendar import monthrange
from sqlConn import sqlConn

# === CONFIGURACIÓN BÁSICA ===
PREDEF_CONN = "ODSPE"
SCHEMA = "dbo"

BASE_TABLE = "PLXS_BASE_PARAMETRICA_MODELO_ATM"
HIST_TABLE = "PLXS_BASE_PARAMETRICA_MODELO_ATM_HIST"

# Clave lógica del ATM (ajustar si la clave real es otra)
KEY_COL = "Nro de ATM"

# Columnas que NO disparan cambio funcional
# (se recalculan dentro del script y no queremos que generen nuevas versiones)
IGNORE_DIFF_COLS = {"INGRESADO", "FECHA_CIERRE", "FECHA CIERRE"}


# ==================== HELPERS ====================

def cargar_df(conn, table_name: str) -> pd.DataFrame:
    """
    Usa sqlConn.descarga_tabla para traer una tabla completa como DataFrame.
    OJO: el primer parámetro se llama 'nombre_base', no 'dataset_name'.
    """
    return conn.descarga_tabla(nombre_base=table_name, schema=SCHEMA)


def set_fechas_nuevos(df: pd.DataFrame, now_ts: pd.Timestamp) -> pd.DataFrame:
    """
    Para los registros NUEVOS que vamos a insertar en el histórico:
      - INGRESADO   = fecha/hora actual (corrida del script)
      - FECHA_CIERRE = último día del mes de now_ts
    """
    if df.empty:
        return df

    if "INGRESADO" in df.columns:
        df["INGRESADO"] = now_ts

    if "FECHA_CIERRE" in df.columns:
        # Último día del mes de now_ts
        last_day = monthrange(now_ts.year, now_ts.month)[1]
        fecha_cierre = pd.Timestamp(year=now_ts.year,
                                    month=now_ts.month,
                                    day=last_day)
        df["FECHA_CIERRE"] = fecha_cierre

    return df


def detectar_cambios(df_actual: pd.DataFrame, df_hist: pd.DataFrame) -> pd.DataFrame:
    """
    Construye el subconjunto de filas que deben agregarse a la tabla histórica.

    Casos:
      - Primera corrida (df_hist vacío): se copia todo df_actual como Carga inicial.
      - IDs nuevos: OBS_CAMBIO = 'Alta de ATM (nuevo ID)'.
      - IDs existentes con alguna columna distinta: OBS_CAMBIO = 'Cambios en: ...'.
      - IDs que estaban en histórico pero no están en la tabla actual:
            OBS_CAMBIO = 'Dado de baja (ATM ya no figura en tabla base)'.
      - IDs que estaban de baja y vuelven a aparecer:
            OBS_CAMBIO = 'Reactivación de ATM (...) [con o sin Cambios en: ...]'.
    """
    now_ts = pd.Timestamp.now()

    # === 1) Primera corrida: histórico vacío -> espejo completo ===
    if df_hist.empty:
        df_nuevos = df_actual.copy()
        df_nuevos["ESTADO_ATM"] = "VIGENTE"
        df_nuevos["OBS_CAMBIO"] = "Carga inicial"
        df_nuevos["FECHA_CAMBIO"] = now_ts
        df_nuevos = set_fechas_nuevos(df_nuevos, now_ts)
        return df_nuevos

    df_hist = df_hist.copy()

    # --- Último registro histórico por clave (KEY_COL) ---
    if "FECHA_CAMBIO" in df_hist.columns:
        df_hist["FECHA_REF"] = df_hist["FECHA_CAMBIO"]
    else:
        df_hist["FECHA_REF"] = pd.NaT

    if "INGRESADO" in df_hist.columns:
        mask = df_hist["FECHA_REF"].isna()
        df_hist.loc[mask, "FECHA_REF"] = df_hist.loc[mask, "INGRESADO"]

    df_hist_sorted = df_hist.sort_values([KEY_COL, "FECHA_REF"])
    df_hist_ult = df_hist_sorted.groupby(KEY_COL, as_index=False).tail(1)

    # --- Merge tabla actual vs último histórico ---
    merged = df_actual.merge(
        df_hist_ult,
        on=KEY_COL,
        how="left",
        suffixes=("_cur", "_prev"),
        indicator=True,
    )

    # Columnas a comparar:
    # Tomamos directamente las columnas *_cur que existan en 'merged',
    # les sacamos el sufijo y filtramos las ignoradas.
    cur_cols = [c for c in merged.columns if c.endswith("_cur")]
    base_cols = []
    for c in cur_cols:
        base_name = c[:-4]  # le saco '_cur'
        if base_name not in IGNORE_DIFF_COLS:
            base_cols.append(base_name)

    def columnas_cambiadas(row):
        cambios = []
        for col in base_cols:
            col_cur = f"{col}_cur"
            col_prev = f"{col}_prev"

            # Usamos get con default para evitar KeyError
            val_cur = row.get(col_cur, pd.NA)
            val_prev = row.get(col_prev, pd.NA)

            # NaN == NaN => sin cambio
            if (pd.isna(val_cur) and pd.isna(val_prev)):
                continue

            if (pd.isna(val_cur) and not pd.isna(val_prev)) or \
               (not pd.isna(val_cur) and pd.isna(val_prev)) or \
               (val_cur != val_prev):
                cambios.append(col)
        return cambios

    # Marcamos cuáles registros son "reactivaciones":
    # ID que estaba dado de baja en el último histórico y vuelve a aparecer en la base.
    merged["ES_REACTIVACION"] = (
        (merged["_merge"] == "both") &
        merged.get("OBS_CAMBIO_prev", "").fillna("").str.contains(
            "Dado de baja", case=False, na=False
        )
    )

    filas_nuevas = []

    # === 2a) IDs nuevos (solo en tabla actual) ===
    nuevos_ids = merged[merged["_merge"] == "left_only"]
    for _, row in nuevos_ids.iterrows():
        registro = {}
        for col in df_actual.columns:
            # Las columnas originales están como *_cur en el merged
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))
        registro["ESTADO_ATM"] = "VIGENTE"
        registro["OBS_CAMBIO"] = "Alta de ATM (nuevo ID)"
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # === 2b) IDs que ya existían: ver si hubo reactivaciones o cambios ===

    # 2b-1) Reactivaciones: último registro histórico era "Dado de baja"
    reactivados = merged[merged["ES_REACTIVACION"]].copy()
    reactivados["CAMBIOS"] = reactivados.apply(columnas_cambiadas, axis=1)

    for _, row in reactivados.iterrows():
        registro = {}
        for col in df_actual.columns:
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))

        cols_cambiadas = row["CAMBIOS"]
        if cols_cambiadas:
            obs = "Reactivación de ATM (estaba dado de baja). Cambios en: " + ", ".join(cols_cambiadas)
        else:
            obs = "Reactivación de ATM (estaba dado de baja)"

        registro["ESTADO_ATM"] = "VIGENTE"
        registro["OBS_CAMBIO"] = obs
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # 2b-2) Cambios normales (IDs que NO son reactivaciones)
    coinciden = merged[(merged["_merge"] == "both") & (~merged["ES_REACTIVACION"])].copy()
    coinciden["CAMBIOS"] = coinciden.apply(columnas_cambiadas, axis=1)

    cambiados = coinciden[coinciden["CAMBIOS"].apply(len) > 0]

    for _, row in cambiados.iterrows():
        registro = {}
        for col in df_actual.columns:
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))

        cols_cambiadas = row["CAMBIOS"]
        obs = "Cambios en: " + ", ".join(cols_cambiadas)

        registro["ESTADO_ATM"] = "VIGENTE"   # luego se recalcula para todo el ID
        registro["OBS_CAMBIO"] = obs
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # === 2c) IDs que desaparecieron en la tabla base (baja de ATM) ===
    ids_hist = set(df_hist_ult[KEY_COL].unique())
    ids_actual = set(df_actual[KEY_COL].unique())
    ids_potenciales_baja = ids_hist - ids_actual

    if ids_potenciales_baja:
        df_baja_base = df_hist_ult[df_hist_ult[KEY_COL].isin(ids_potenciales_baja)].copy()

        # Marcar cuáles de esos ya están dados de baja en su ÚLTIMO registro
        df_baja_base["ES_BAJA"] = df_baja_base["OBS_CAMBIO"].fillna("").str.contains(
            "Dado de baja", case=False, na=False
        )

        # Solo queremos generar baja para los que todavía NO tienen registro de baja
        df_baja_nuevos = df_baja_base[~df_baja_base["ES_BAJA"]]

        for _, row in df_baja_nuevos.iterrows():
            registro = {}
            # Copiamos los últimos valores conocidos de las columnas de negocio
            for col in df_actual.columns:
                registro[col] = row[col]
            registro["ESTADO_ATM"] = "ANTERIOR"
            registro["OBS_CAMBIO"] = "Dado de baja (ATM ya no figura en tabla base)"
            registro["FECHA_CAMBIO"] = now_ts
            filas_nuevas.append(registro)

    if not filas_nuevas:
        # No hay nada que agregar al histórico hoy
        return pd.DataFrame(
            columns=list(df_actual.columns) +
                    ["ESTADO_ATM", "OBS_CAMBIO", "FECHA_CAMBIO"]
        )

    df_nuevos = pd.DataFrame(filas_nuevas)
    df_nuevos = set_fechas_nuevos(df_nuevos, now_ts)
    return df_nuevos


def recalcular_estados(df_hist_total: pd.DataFrame) -> pd.DataFrame:
    """
    A partir del histórico completo (viejos + nuevos), recalcula ESTADO_ATM.

    Regla:
      - Para cada ID (Nro de ATM), se mira el último registro
        (por FECHA_CAMBIO o INGRESADO).
      - Si el último registro tiene OBS_CAMBIO que contiene 'Dado de baja':
            -> TODOS los registros de ese ID quedan como 'ANTERIOR'
               (no hay versión vigente).
      - En caso contrario:
            -> El último registro queda 'VIGENTE'
            -> Los anteriores quedan 'ANTERIOR'
    """
    df = df_hist_total.copy()

    if "FECHA_CAMBIO" in df.columns:
        df["FECHA_REF"] = df["FECHA_CAMBIO"]
    else:
        df["FECHA_REF"] = pd.NaT

    if "INGRESADO" in df.columns:
        mask = df["FECHA_REF"].isna()
        df.loc[mask, "FECHA_REF"] = df.loc[mask, "INGRESADO"]

    df.sort_values([KEY_COL, "FECHA_REF"], inplace=True)

    df["ESTADO_ATM"] = "ANTERIOR"
    idx_ultimos = df.groupby(KEY_COL)["FECHA_REF"].idxmax()

    # Último registro por ID
    ultimos = df.loc[idx_ultimos, [KEY_COL, "OBS_CAMBIO"]].copy()
    ultimos["ES_BAJA"] = ultimos["OBS_CAMBIO"].fillna("").str.contains(
        "Dado de baja", case=False, na=False
    )

    ids_baja = set(ultimos[ultimos["ES_BAJA"]][KEY_COL].unique())

    # IDs que NO están dados de baja → último registro = VIGENTE
    idx_vigentes = [
        idx for idx in idx_ultimos
        if df.at[idx, KEY_COL] not in ids_baja
    ]
    df.loc[idx_vigentes, "ESTADO_ATM"] = "VIGENTE"

    df.drop(columns=["FECHA_REF"], inplace=True)
    return df


# ==================== SCRIPT PRINCIPAL ====================

def run():
    """
    Script histórico para PLXS_BASE_PARAMETRICA_MODELO_ATM_HIST.
    Pensado para ejecutarse después del vuelco diario de la tabla base.
    """
    conn = sqlConn(predef_conn=PREDEF_CONN, agendado=False)

    try:
        # 1) Tabla actual (paramétrica diaria)
        df_actual = cargar_df(conn, BASE_TABLE)

        # 2) Ver si la tabla histórica existe
        existe_hist = False
        try:
            if hasattr(conn, "table_exists"):
                existe_hist = conn.table_exists(table=HIST_TABLE, schema=SCHEMA)
        except Exception as e:
            print(f"[{HIST_TABLE}] WARNING al verificar existencia de tabla:", e)
            existe_hist = False

        # 3) Tabla histórica (si existe)
        if existe_hist:
            df_hist = cargar_df(conn, HIST_TABLE)
        else:
            df_hist = pd.DataFrame()

        # 4) Ver qué filas nuevas hay que agregar al histórico
        df_nuevos = detectar_cambios(df_actual, df_hist)

        if df_nuevos.empty:
            print("[HIST] Sin cambios; no se modifica PLXS_BASE_PARAMETRICA_MODELO_ATM_HIST.")
            return

        # 5) Concatenar histórico viejo + nuevos
        if df_hist.empty:
            df_hist_total = df_nuevos
        else:
            df_hist_total = pd.concat([df_hist, df_nuevos], ignore_index=True)

        # 6) Recalcular ESTADO_ATM por ID
        df_hist_total = recalcular_estados(df_hist_total)

        # 7) TRUNCATE + INSERT (porque en ODSPE no se quieren UPDATEs)
        try:
            if existe_hist:
                conn.truncar_tabla(dataset_name=HIST_TABLE, schema=SCHEMA)
                print(f"[{HIST_TABLE}] TRUNCATE OK")
        except Exception as e:
            print(f"[{HIST_TABLE}] WARNING en TRUNCATE:", e)

        # crea_tabla debería crear la tabla si no existe
        conn.crea_tabla(df_hist_total, HIST_TABLE, if_exists="append")
        print(f"[{HIST_TABLE}] Insertados {len(df_hist_total)} registros en total.")

    finally:
        try:
            conn.desconecta()
        except Exception:
            pass


if __name__ == "__main__":
    run()
