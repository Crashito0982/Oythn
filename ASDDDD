import pandas as pd
from sqlConn import sqlConn

# ============================================
# CONFIGURACIÓN GENERAL
# ============================================

# Ajustá esta conexión al motor donde están las tablas de bóveda
PREDEF_CONN = "AT_CMDTS"
SCHEMA = "dbo"

# Definición de cada tabla base / histórica y su clave
TABLAS_BOVEDA = [
    {
        "BASE_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_INDICE_SUCURSALES",
        "HIST_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_INDICE_SUCURSALES_HIST",
        "KEY_COLS": ["SUCURSALES"],
        "ENTIDAD_LABEL": "índice de sucursal de bóveda",
        "BAJA_LABEL": "índice de sucursal ya no figura en tabla base",
    },
    {
        "BASE_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_ATM",
        "HIST_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_ATM_HIST",
        "KEY_COLS": ["LUNO"],
        "ENTIDAD_LABEL": "ATM de bóveda",
        "BAJA_LABEL": "ATM de bóveda ya no figura en tabla base",
    },
    {
        "BASE_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_LIMITES",
        "HIST_TABLE": "PLXS_BASE_PARAMETRICA_MODELO_BOVEDA_LIMITES_HIST",
        "KEY_COLS": ["TRANSPORTADORA", "DELEGACION"],
        "ENTIDAD_LABEL": "límite de bóveda",
        "BAJA_LABEL": "límite de bóveda ya no figura en tabla base",
    },
]

STATUS_COL = "ESTADO_REGISTRO"
IGNORE_DIFF_COLS = {"FECHA_CREACION"}  # columnas que no disparan cambio


# ============================================
# HELPERS GENERALES
# ============================================

def cargar_df(conn, table_name: str) -> pd.DataFrame:
    """
    Usa sqlConn.descarga_tabla para traer una tabla completa como DataFrame.
    """
    return conn.descarga_tabla(nombre_base=table_name, schema=SCHEMA)


def key_tuple_from_row(row, key_cols, suffix: str = ""):
    if len(key_cols) == 1:
        return row.get(key_cols[0] + suffix, row.get(key_cols[0]))
    return tuple(row.get(col + suffix, row.get(col)) for col in key_cols)


def build_key_set(df: pd.DataFrame, key_cols):
    if df.empty:
        return set()
    if len(key_cols) == 1:
        return set(df[key_cols[0]].dropna().unique())
    return set(tuple(r) for r in df[key_cols].dropna().itertuples(index=False, name=None))


def detectar_cambios_generico(df_actual: pd.DataFrame,
                              df_hist: pd.DataFrame,
                              key_cols,
                              status_col: str,
                              ignore_diff_cols=None,
                              entidad_label: str = "registro",
                              baja_label: str = "registro ya no figura en tabla base") -> pd.DataFrame:
    """
    Devuelve SOLO las filas nuevas que deben agregarse a la tabla histórica.
    (Altas, cambios, bajas, reactivaciones)
    """
    ignore_diff_cols = set(ignore_diff_cols or set())
    now_ts = pd.Timestamp.now()

    # 1) Primera corrida: histórico vacío -> espejo completo
    if df_hist.empty:
        df_nuevos = df_actual.copy()
        df_nuevos[status_col] = "VIGENTE"
        df_nuevos["OBS_CAMBIO"] = "Carga inicial"
        df_nuevos["FECHA_CAMBIO"] = now_ts
        return df_nuevos

    df_hist = df_hist.copy()

    # FECHA_REF para ordenar versiones
    if "FECHA_CAMBIO" in df_hist.columns:
        df_hist["FECHA_REF"] = df_hist["FECHA_CAMBIO"]
    else:
        df_hist["FECHA_REF"] = pd.NaT

    # fallback a FECHA_CREACION si no hubiera FECHA_CAMBIO
    if "FECHA_CREACION" in df_hist.columns:
        mask = df_hist["FECHA_REF"].isna()
        df_hist.loc[mask, "FECHA_REF"] = df_hist.loc[mask, "FECHA_CREACION"]

    df_hist_sorted = df_hist.sort_values(list(key_cols) + ["FECHA_REF"])
    df_hist_ult = df_hist_sorted.groupby(list(key_cols), as_index=False).tail(1)

    # Merge actual vs última versión por clave
    merged = df_actual.merge(
        df_hist_ult,
        on=list(key_cols),
        how="left",
        suffixes=("_cur", "_prev"),
        indicator=True,
    )

    # Columnas de negocio a comparar (solo las que vienen de la tabla actual)
    cur_cols = [c for c in merged.columns if c.endswith("_cur")]
    base_cols = []
    for c in cur_cols:
        base_name = c[:-4]
        if base_name not in ignore_diff_cols and base_name not in {status_col, "OBS_CAMBIO", "FECHA_CAMBIO"}:
            base_cols.append(base_name)

    def columnas_cambiadas(row):
        cambios = []
        for col in base_cols:
            col_cur = f"{col}_cur"
            col_prev = f"{col}_prev"
            val_cur = row.get(col_cur, pd.NA)
            val_prev = row.get(col_prev, pd.NA)

            if pd.isna(val_cur) and pd.isna(val_prev):
                continue
            if (pd.isna(val_cur) and not pd.isna(val_prev)) or \
               (not pd.isna(val_cur) and pd.isna(val_prev)) or \
               (val_cur != val_prev):
                cambios.append(col)
        return cambios

    # IDs cuya última versión está dada de baja
    if "OBS_CAMBIO" in df_hist_ult.columns:
        mask_baja = df_hist_ult["OBS_CAMBIO"].fillna("").str.contains(
            r"^\s*Dado de baja\b", case=False, na=False, regex=True
        )
        if len(key_cols) == 1:
            ids_baja_hist = set(df_hist_ult.loc[mask_baja, key_cols[0]].unique())
        else:
            ids_baja_hist = set(
                tuple(row[col] for col in key_cols)
                for _, row in df_hist_ult.loc[mask_baja, key_cols].iterrows()
            )
    else:
        ids_baja_hist = set()

    ids_actual = build_key_set(df_actual, key_cols)
    ids_reactivados = ids_actual & ids_baja_hist

    def is_reactivacion(row):
        if row["_merge"] != "both":
            return False
        key = key_tuple_from_row(row, key_cols, "")
        return key in ids_reactivados

    merged["ES_REACTIVACION"] = merged.apply(is_reactivacion, axis=1)

    filas_nuevas = []

    # 2a) Altas: claves nuevas que solo están en la tabla base
    nuevos_ids = merged[merged["_merge"] == "left_only"]
    for _, row in nuevos_ids.iterrows():
        registro = {}
        for col in df_actual.columns:
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))
        registro[status_col] = "VIGENTE"
        registro["OBS_CAMBIO"] = f"Alta de {entidad_label} (nuevo ID)"
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # 2b) Reactivaciones
    reactivados = merged[merged["ES_REACTIVACION"]].copy()
    if not reactivados.empty:
        reactivados["CAMBIOS"] = reactivados.apply(columnas_cambiadas, axis=1)
        for _, row in reactivados.iterrows():
            registro = {}
            for col in df_actual.columns:
                registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))
            cols_cambiadas = row["CAMBIOS"]
            if cols_cambiadas:
                obs = f"Reactivación de {entidad_label} (estaba dado de baja). Cambios en: " + ", ".join(cols_cambiadas)
            else:
                obs = f"Reactivación de {entidad_label} (estaba dado de baja)"
            registro[status_col] = "VIGENTE"
            registro["OBS_CAMBIO"] = obs
            registro["FECHA_CAMBIO"] = now_ts
            filas_nuevas.append(registro)

    # 2c) Cambios normales en registros existentes
    coinciden = merged[(merged["_merge"] == "both") & (~merged["ES_REACTIVACION"])].copy()
    if not coinciden.empty:
        coinciden["CAMBIOS"] = coinciden.apply(columnas_cambiadas, axis=1)
        cambiados = coinciden[coinciden["CAMBIOS"].apply(len) > 0]
        for _, row in cambiados.iterrows():
            registro = {}
            for col in df_actual.columns:
                registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))
            cols_cambiadas = row["CAMBIOS"]
            obs = "Cambios en: " + ", ".join(cols_cambiadas)
            registro[status_col] = "VIGENTE"
            registro["OBS_CAMBIO"] = obs
            registro["FECHA_CAMBIO"] = now_ts
            filas_nuevas.append(registro)

    # 2d) Bajas: claves que estaban en el histórico y ya no están en la tabla base
    if len(key_cols) == 1:
        ids_hist = set(df_hist_ult[key_cols[0]].unique())
    else:
        ids_hist = set(
            tuple(row[col] for col in key_cols)
            for _, row in df_hist_ult[key_cols].iterrows()
        )
    ids_pot_baja = ids_hist - ids_actual

    if ids_pot_baja:
        df_baja_base = df_hist_ult.copy()
        df_baja_base["ES_BAJA"] = df_baja_base["OBS_CAMBIO"].fillna("").str.contains(
            r"^\s*Dado de baja\b", case=False, na=False, regex=True
        )

        def key_in_pot(row):
            key = tuple(row[col] for col in key_cols) if len(key_cols) > 1 else row[key_cols[0]]
            return key in ids_pot_baja

        df_baja_base = df_baja_base[df_baja_base.apply(key_in_pot, axis=1)]
        df_baja_nuevos = df_baja_base[~df_baja_base["ES_BAJA"]]

        for _, row in df_baja_nuevos.iterrows():
            registro = {}
            for col in df_actual.columns:
                registro[col] = row.get(col, pd.NA)
            registro[status_col] = "ANTERIOR"
            registro["OBS_CAMBIO"] = f"Dado de baja ({baja_label})"
            registro["FECHA_CAMBIO"] = now_ts
            filas_nuevas.append(registro)

    if not filas_nuevas:
        # Nada que agregar hoy
        return pd.DataFrame(columns=list(df_actual.columns) + [status_col, "OBS_CAMBIO", "FECHA_CAMBIO"])

    return pd.DataFrame(filas_nuevas)


def recalcular_estados_generico(df_hist_total: pd.DataFrame,
                                key_cols,
                                status_col: str) -> pd.DataFrame:
    """
    A partir del histórico completo, recalcula ESTADO_REGISTRO:

      - Si el último registro por clave es una baja ("Dado de baja..."):
            todos quedan ANTERIOR.
      - Si no es baja:
            el último queda VIGENTE, los anteriores ANTERIOR.
    """
    df = df_hist_total.copy()

    if "FECHA_CAMBIO" in df.columns:
        df["FECHA_REF"] = df["FECHA_CAMBIO"]
    else:
        df["FECHA_REF"] = pd.NaT

    if "FECHA_CREACION" in df.columns:
        mask = df["FECHA_REF"].isna()
        df.loc[mask, "FECHA_REF"] = df.loc[mask, "FECHA_CREACION"]

    df.sort_values(list(key_cols) + ["FECHA_REF"], inplace=True)
    df[status_col] = "ANTERIOR"

    idx_ultimos = df.groupby(list(key_cols))["FECHA_REF"].idxmax()

    ultimos = df.loc[idx_ultimos, list(key_cols) + ["OBS_CAMBIO"]].copy()
    ultimos["ES_BAJA"] = ultimos["OBS_CAMBIO"].fillna("").str.contains(
        r"^\s*Dado de baja\b", case=False, na=False, regex=True
    )

    if len(key_cols) == 1:
        ids_baja = set(ultimos.loc[ultimos["ES_BAJA"], key_cols[0]].unique())
    else:
        ids_baja = set(
            tuple(row[col] for col in key_cols)
            for _, row in ultimos[ultimos["ES_BAJA"]][key_cols].iterrows()
        )

    idx_vigentes = []
    for idx in idx_ultimos:
        row = df.loc[idx]
        if len(key_cols) == 1:
            key = row[key_cols[0]]
        else:
            key = tuple(row[col] for col in key_cols)
        if key not in ids_baja:
            idx_vigentes.append(idx)

    df.loc[idx_vigentes, status_col] = "VIGENTE"

    df.drop(columns=["FECHA_REF"], inplace=True)
    return df


# ============================================
# PROCESO POR TABLA
# ============================================

def procesar_tabla_boveda(conn, cfg: dict):
    base_table = cfg["BASE_TABLE"]
    hist_table = cfg["HIST_TABLE"]
    key_cols = cfg["KEY_COLS"]
    entidad_label = cfg["ENTIDAD_LABEL"]
    baja_label = cfg["BAJA_LABEL"]

    print(f"\n[HIST] Procesando histórico para {base_table} -> {hist_table}")

    df_actual = cargar_df(conn, base_table)

    # Verificar existencia de tabla histórica
    existe_hist = False
    try:
        if hasattr(conn, "table_exists"):
            existe_hist = conn.table_exists(table=hist_table, schema=SCHEMA)
    except Exception as e:
        print(f"[{hist_table}] WARNING al verificar existencia de tabla:", e)
        existe_hist = False

    if existe_hist:
        df_hist = cargar_df(conn, hist_table)
    else:
        df_hist = pd.DataFrame()

    df_nuevos = detectar_cambios_generico(
        df_actual=df_actual,
        df_hist=df_hist,
        key_cols=key_cols,
        status_col=STATUS_COL,
        ignore_diff_cols=IGNORE_DIFF_COLS,
        entidad_label=entidad_label,
        baja_label=baja_label,
    )

    if df_nuevos.empty:
        print(f"[{hist_table}] Sin cambios; no se modifica la tabla histórica.")
        return

    if df_hist.empty:
        df_hist_total = df_nuevos
    else:
        df_hist_total = pd.concat([df_hist, df_nuevos], ignore_index=True)

    df_hist_total = recalcular_estados_generico(
        df_hist_total=df_hist_total,
        key_cols=key_cols,
        status_col=STATUS_COL,
    )

    # TRUNCATE + INSERT
    try:
        if existe_hist:
            conn.truncar_tabla(dataset_name=hist_table, schema=SCHEMA)
            print(f"[{hist_table}] TRUNCATE OK")
    except Exception as e:
        print(f"[{hist_table}] WARNING en TRUNCATE:", e)

    conn.crea_tabla(df_hist_total, hist_table, if_exists="append")
    print(f"[{hist_table}] Insertados {len(df_hist_total)} registros en total.")


# ============================================
# ORQUESTADOR
# ============================================

def run():
    conn = sqlConn(predef_conn=PREDEF_CONN, agendado=False)

    try:
        for cfg in TABLAS_BOVEDA:
            procesar_tabla_boveda(conn, cfg)
    finally:
        try:
            conn.desconecta()
        except Exception:
            pass


if __name__ == "__main__":
    run()
