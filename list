def detectar_cambios(df_actual: pd.DataFrame, df_hist: pd.DataFrame) -> pd.DataFrame:
    """
    Construye el subconjunto de filas que deben agregarse a la tabla histórica.

    Casos:
      - Primera corrida (df_hist vacío): se copia todo df_actual como Carga inicial.
      - IDs nuevos: OBS_CAMBIO = 'Alta de ATM (nuevo ID)'.
      - IDs existentes con alguna columna distinta: OBS_CAMBIO = 'Cambios en: ...'.
      - IDs que estaban en histórico pero no están en la tabla actual:
            OBS_CAMBIO = 'Dado de baja (ATM ya no figura en tabla base)'.
    """
    now_ts = pd.Timestamp.now()

    # === 1) Primera corrida: histórico vacío -> espejo completo ===
    if df_hist.empty:
        df_nuevos = df_actual.copy()
        df_nuevos["ESTADO_ATM"] = "VIGENTE"
        df_nuevos["OBS_CAMBIO"] = "Carga inicial"
        df_nuevos["FECHA_CAMBIO"] = now_ts
        return df_nuevos

    df_hist = df_hist.copy()

    # --- Último registro histórico por clave (KEY_COL) ---
    if "FECHA_CAMBIO" in df_hist.columns:
        df_hist["FECHA_REF"] = df_hist["FECHA_CAMBIO"]
    else:
        df_hist["FECHA_REF"] = pd.NaT

    if "INGRESADO" in df_hist.columns:
        mask = df_hist["FECHA_REF"].isna()
        df_hist.loc[mask, "FECHA_REF"] = df_hist.loc[mask, "INGRESADO"]

    df_hist_sorted = df_hist.sort_values([KEY_COL, "FECHA_REF"])
    df_hist_ult = df_hist_sorted.groupby(KEY_COL, as_index=False).tail(1)

    # --- Merge tabla actual vs último histórico ---
    merged = df_actual.merge(
        df_hist_ult,
        on=KEY_COL,
        how="left",
        suffixes=("_cur", "_prev"),
        indicator=True,
    )

    # Columnas a comparar:
    # Tomamos directamente las columnas *_cur que existan en 'merged',
    # les sacamos el sufijo y filtramos las ignoradas.
    cur_cols = [c for c in merged.columns if c.endswith("_cur")]
    base_cols = []
    for c in cur_cols:
        base_name = c[:-4]  # le saco '_cur'
        if base_name not in IGNORE_DIFF_COLS:
            base_cols.append(base_name)

    def columnas_cambiadas(row):
        cambios = []
        for col in base_cols:
            col_cur = f"{col}_cur"
            col_prev = f"{col}_prev"

            # Usamos get con default para evitar KeyError
            val_cur = row.get(col_cur, pd.NA)
            val_prev = row.get(col_prev, pd.NA)

            # NaN == NaN => sin cambio
            if (pd.isna(val_cur) and pd.isna(val_prev)):
                continue

            if (pd.isna(val_cur) and not pd.isna(val_prev)) or \
               (not pd.isna(val_cur) and pd.isna(val_prev)) or \
               (val_cur != val_prev):
                cambios.append(col)
        return cambios

    filas_nuevas = []

    # === 2a) IDs nuevos (solo en tabla actual) ===
    nuevos_ids = merged[merged["_merge"] == "left_only"]
    for _, row in nuevos_ids.iterrows():
        registro = {}
        for col in df_actual.columns:
            # Las columnas originales están como *_cur en el merged
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))
        registro["ESTADO_ATM"] = "VIGENTE"
        registro["OBS_CAMBIO"] = "Alta de ATM (nuevo ID)"
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # === 2b) IDs que ya existían: ver si alguna columna cambió ===
    coinciden = merged[merged["_merge"] == "both"].copy()
    coinciden["CAMBIOS"] = coinciden.apply(columnas_cambiadas, axis=1)

    cambiados = coinciden[coinciden["CAMBIOS"].apply(len) > 0]

    for _, row in cambiados.iterrows():
        registro = {}
        for col in df_actual.columns:
            registro[col] = row.get(col, row.get(f"{col}_cur", pd.NA))

        cols_cambiadas = row["CAMBIOS"]
        obs = "Cambios en: " + ", ".join(cols_cambiadas)

        registro["ESTADO_ATM"] = "VIGENTE"   # luego se recalcula para todo el ID
        registro["OBS_CAMBIO"] = obs
        registro["FECHA_CAMBIO"] = now_ts
        filas_nuevas.append(registro)

    # === 2c) IDs que desaparecieron en la tabla base (baja de ATM) ===
    ids_hist = set(df_hist_ult[KEY_COL].unique())
    ids_actual = set(df_actual[KEY_COL].unique())
    ids_baja = ids_hist - ids_actual

    if ids_baja:
        df_baja_base = df_hist_ult[df_hist_ult[KEY_COL].isin(ids_baja)]
        for _, row in df_baja_base.iterrows():
            registro = {}
            # Copiamos los últimos valores conocidos de las columnas de negocio
            for col in df_actual.columns:
                registro[col] = row[col]
            registro["ESTADO_ATM"] = "ANTERIOR"
            registro["OBS_CAMBIO"] = "Dado de baja (ATM ya no figura en tabla base)"
            registro["FECHA_CAMBIO"] = now_ts
            filas_nuevas.append(registro)

    if not filas_nuevas:
        # No hay nada que agregar al histórico hoy
        return pd.DataFrame(
            columns=list(df_actual.columns) +
                    ["ESTADO_ATM", "OBS_CAMBIO", "FECHA_CAMBIO"]
        )

    return pd.DataFrame(filas_nuevas)
